<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Babylon.js - AR Géolocalisée</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        html, body { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #info { position: absolute; bottom: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-family: sans-serif; font-size: 14px; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="info">Initialisation...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const infoDiv = document.getElementById('info');

        // --- Paramètres de la scène ---
        const distance = 50;      // Distance des cubes en mètres
        const cubeSize = 3;       // Taille des cubes en mètres
        const smoothingFactor = 0.05; // Facteur de lissage (plus petit = plus lisse)

        // Variables pour le lissage de l'orientation
        let targetAngleY = 0;
        let smoothedAngleY = 0;

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, 0), scene);
            
            // Placement fixe des cubes dans l'espace 3D
            // En Babylon.js : +Z = Devant, +X = Droite
            
            const cubeNorth = BABYLON.MeshBuilder.CreateBox("Nord", { size: cubeSize }, scene);
            cubeNorth.position = new BABYLON.Vector3(0, 0, distance);
            cubeNorth.material = new BABYLON.StandardMaterial("matN", scene);
            cubeNorth.material.emissiveColor = BABYLON.Color3.Red();

            const cubeEast = BABYLON.MeshBuilder.CreateBox("Est", { size: cubeSize }, scene);
            cubeEast.position = new BABYLON.Vector3(distance, 0, 0);
            cubeEast.material = new BABYLON.StandardMaterial("matE", scene);
            cubeEast.material.emissiveColor = BABYLON.Color3.Green();

            const cubeSouth = BABYLON.MeshBuilder.CreateBox("Sud", { size: cubeSize }, scene);
            cubeSouth.position = new BABYLON.Vector3(0, 0, -distance);
            cubeSouth.material = new BABYLON.StandardMaterial("matS", scene);
            cubeSouth.material.emissiveColor = BABYLON.Color3.Blue();

            const cubeWest = BABYLON.MeshBuilder.CreateBox("Ouest", { size: cubeSize }, scene);
            cubeWest.position = new BABYLON.Vector3(-distance, 0, 0);
            cubeWest.material = new BABYLON.StandardMaterial("matW", scene);
            cubeWest.material.emissiveColor = BABYLON.Color3.Yellow();

            setupARBackground(scene);
            setupOrientationListener(); 

            return scene;
        };

        const setupARBackground = (scene) => {
            // Active la caméra de l'appareil en arrière-plan.
            // **IMPORTANT : Nécessite une connexion HTTPS.**
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                .then(stream => {
                    const video = document.createElement('video');
                    video.setAttribute('playsinline', '');
                    video.setAttribute('autoplay', '');
                    video.srcObject = stream;
                    video.play();
                    
                    const background = new BABYLON.Layer("background", null, scene, true);
                    background.texture = new BABYLON.VideoTexture("video", video, scene, true);
                }).catch(err => {
                    infoDiv.innerHTML = "<strong>Erreur:</strong> Caméra inaccessible. Assurez-vous d'utiliser <strong>HTTPS</strong>.";
                });
        };

        const setupOrientationListener = () => {
            window.addEventListener("deviceorientationabsolute", (event) => {
                if (event.alpha !== null) {
                    // Met à jour l'angle cible avec la valeur de la boussole.
                    // La rotation est inversée pour correspondre au système de coordonnées de Babylon.js.
                    targetAngleY = -event.alpha;
                    infoDiv.textContent = `Cap: ${event.alpha.toFixed(1)}°`;
                }
            }, true);
        };

        const scene = createScene();
        
        engine.runRenderLoop(() => {
            // Lissage de la rotation de la caméra à chaque image.
            // Calcule le chemin le plus court pour la rotation (gère le passage de 359° à 1°).
            let delta = targetAngleY - smoothedAngleY;
            if (delta > 180) {
                delta -= 360;
            } else if (delta < -180) {
                delta += 360;
            }
            
            // Se rapproche de l'angle cible en utilisant le facteur de lissage.
            smoothedAngleY += delta * smoothingFactor;
            
            // Applique l'angle lissé à la caméra.
            scene.activeCamera.rotation.y = BABYLON.Tools.ToRadians(smoothedAngleY);
            
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>